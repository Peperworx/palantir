//! # Transports
//! Palantir does not restrict itself to a particular protocol while communicating between peers.
//! The [`Transport`] trait will help to abstract over different protocols.

use thiserror::Error;

use std::{sync::Arc, future::Future};

use crate::{PeerId, ConnectionId, Message};


#[derive(Error, Debug)]
pub enum TransportError {
    /// A response from a peer failed
    #[error("peer response failed")]
    ResponseReceiveFailed,
    /// A message failed to be sent to a peer
    #[error("message send failed")]
    SendFailed,
    /// Failed to receive a message from a peer
    #[error("message receive failed")]
    ReceiveFailed,
    /// Failed to send a response to a peer
    #[error("response failed")]
    ResponseSendFailed,
}


/// # [`Transport`]
/// Abstracts over a protocol or suite of protocols used for communication between peers.
/// Note that a [`Transport`] only knows about peers that are directly "adjacent" to this peer:
/// that is, have a direct connection with the peer. Messages may need to be routed between peers,
/// and that is what networks are for.
/// 
/// ## Handling Peers
/// Transports are responsible for determining peer ids.
/// There is only one real requirement for Peer Ids: that they are deterministic.
/// This means that every node on the network should agree on an ID for a peer.
/// In situations where a relay server is involved, this is simple: the relay server generates Ids.
/// However, in more complex scenarios, Peer Ids should be generated by the SHA3-512 hash of the peer's ECDSA public key.
/// In the future, Dilithium should be used instead of ECDSA, and Palantir will migrate once Dilithium is standardized.
#[async_trait::async_trait]
pub trait Transport<M: Message> {

    /// Retrieves every known peer id.
    fn get_peers(&self) -> Vec<PeerId>;

    /// Waits until new peer(s) are available. If multiple peers become available at the same time,
    /// multiple peers will be returned.
    async fn wait_for_new_peer(&self) -> Vec<PeerId>;

    /// Lists every connection for a given peer
    fn get_connections_by_peer(&self, peer: PeerId) -> Vec<ConnectionId>;

    /// Waits for a new connection, returning the ConnectionId
    async fn wait_for_new_connection(&self) -> Vec<PeerId>;

    /// Given a Peer ID, get a [`PeerHandle`], which enables sending and receiving messages
    /// from a peer.
    async fn get_peer_handle(&self, peer: PeerId) -> Arc<PeerHandle<M>>;
}


/// # [`PeerHandle`]
/// Wraps send and recieve channels of which the other ends are held by a 
/// [`Transport`], and allows communication with a peer.
pub struct PeerHandle<M: Message> {
    /// Outbound message channel (messages being sent TO the peer)
    outbound: kanal::AsyncSender<(M, kanal::OneshotAsyncSender<M::Response>)>,
    /// Inbound message channel (messages being received FROM the peer)
    inbound: kanal::AsyncReceiver<(M, kanal::OneshotAsyncSender<M::Response>)>,
}


impl<M: Message> PeerHandle<M> {

    /// Send a message to the peer and wait for a response
    pub async fn send(&self, message: M) -> Result<M::Response, TransportError> {
        // Create a response channel
        let (responder, response) = kanal::oneshot_async();

        // Send the message
        self.outbound.send((message, responder)).await.map_err(|_| TransportError::SendFailed)?;

        // Wait for a response
        response.recv().await.map_err(|_| TransportError::ResponseReceiveFailed)
    }

    /// Wait for a message from the peer, passing its contents to the given closure
    /// and sending the closure's return type as a response
    pub async fn recv<F, Fut>(&self, f: F) -> Result<(), TransportError>
    where
        F: FnOnce(M) -> Fut,
        Fut: Future<Output = Result<M::Response, TransportError>>
    {
        // Wait for a message
        let m = self.inbound.recv().await.map_err(|_| TransportError::ReceiveFailed)?;

        // Run the handling function
        let res = f(m.0).await?;

        // Send the response
        m.1.send(res).await.map_err(|_| TransportError::ResponseSendFailed)
    }
}