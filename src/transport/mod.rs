//! # Transports
//! Palantir does not restrict itself to a particular protocol while communicating between peers.
//! The [`Transport`] trait will help to abstract over different protocols.

use thiserror::Error;

use std::{sync::Arc, future::Future};

use crate::{PeerId, ConnectionId, Message};

pub mod wtransport;

#[derive(Error, Debug)]
pub enum TransportError {
    /// A response from a peer failed
    #[error("peer response failed")]
    ResponseReceiveFailed,
    /// A message failed to be sent to a peer
    #[error("message send failed")]
    SendFailed,
    /// Failed to receive a message from a peer
    #[error("message receive failed")]
    ReceiveFailed,
    /// Failed to send a response to a peer
    #[error("response failed")]
    ResponseSendFailed,
}


/// # [`Transport`]
/// Abstracts over a protocol or suite of protocols used for communication between peers.
/// Note that a [`Transport`] only knows about peers that are directly "adjacent" to this peer:
/// that is, have a direct connection with the peer. Messages may need to be routed between peers,
/// and that is what networks are for.
/// 
/// ## Handling Peers
/// Transports are responsible for determining peer ids.
/// There is only one real requirement for Peer Ids: that they are deterministic.
/// This means that every node on the network should agree on an ID for a peer.
/// In situations where a relay server is involved, this is simple: the relay server generates Ids.
/// However, in more complex scenarios, Peer Ids should be generated by the SHA2-512 hash of the peer's ECDSA public key.
/// In the future, Dilithium should be used instead of ECDSA, and Palantir will migrate once Dilithium is standardized.
///
/// Transports should also provide authentication, however Authorization should be provided elsewhere.
#[async_trait::async_trait]
pub trait Transport<M: Message> {

    /// Retrieves every known peer id.
    fn get_peers(&self) -> Vec<PeerId>;

    /// Waits until new peer(s) are available. If multiple peers become available at the same time,
    /// multiple peers will be returned.
    async fn wait_for_new_peer(&self) -> Vec<PeerId>;

    /// Lists every connection for a given peer
    fn get_connections_by_peer(&self, peer: PeerId) -> Vec<ConnectionId>;

    /// Waits for a new connection, returning the ConnectionId
    async fn wait_for_new_connection(&self) -> Vec<PeerId>;

    /// Given a Connection ID, returns a [`ConnectionHandle`], which enables sending and receiving messages
    /// from a peer over a specific connection.
    async fn get_connection_handle(&self, connection: ConnectionId) -> Arc<ConnectionHandle<M>>;
}

/// # [`TransportControlMessage`]
/// A transport control message is sent by a [`ConnectionHandle`] and is used to provide commands to the transport.
pub enum TransportControlMessage {
    /// Drop the connection that this message was sent from.
    DropConnection,
    /// Drop all connections owned by the same peer as the connection this message was sent from.
    DropPeer,
}

/// # [`ConnectionHandle`]
/// Wraps send and recieve channels of which the other ends are held by a 
/// [`Transport`], and allows communication with a connection.
/// It should be noted that multiple connection handlers are *not* guarenteed to receive every message,
/// and that at most one connection handler should be used 
pub struct ConnectionHandle<M: Message> {
    /// Outbound message channel (messages being sent TO the peer)
    outbound: kanal::AsyncSender<(M, kanal::OneshotAsyncSender<M::Response>)>,
    /// Inbound message channel (messages being received FROM the peer)
    inbound: kanal::AsyncReceiver<(M, kanal::OneshotAsyncSender<M::Response>)>,
    /// The control channel, used to send commands to the task handling the connection.
    control: kanal::AsyncSender<TransportControlMessage>,
}


impl<M: Message> ConnectionHandle<M> {

    /// Drop this connection
    /// If this fails, it returns None.
    /// 
    pub async fn close(&self) -> Option<()>{
        self.control.send(TransportControlMessage::DropConnection).await.ok()
    }

    /// Drop all connections owned by the same peer as this one
    /// If this fails, it returns None.
    /// This may mean that some connections still exist.
    pub async fn close_all(&self) -> Option<()> {
        self.control.send(TransportControlMessage::DropPeer).await.ok()
    }

    /// Send a message to the peer and wait for a response
    pub async fn send(&self, message: M) -> Result<M::Response, TransportError> {
        // Create a response channel
        let (responder, response) = kanal::oneshot_async();

        // Send the message
        self.outbound.send((message, responder)).await.map_err(|_| TransportError::SendFailed)?;

        // Wait for a response
        response.recv().await.map_err(|_| TransportError::ResponseReceiveFailed)
    }

    /// Wait for a message from the peer, passing its contents to the given closure
    /// and sending the closure's return type as a response
    pub async fn recv<F, Fut>(&self, f: F) -> Result<(), TransportError>
    where
        F: FnOnce(M) -> Fut,
        Fut: Future<Output = Result<M::Response, TransportError>>
    {
        // Wait for a message
        let m = self.inbound.recv().await.map_err(|_| TransportError::ReceiveFailed)?;

        // Run the handling function
        let res = f(m.0).await?;

        // Send the response
        m.1.send(res).await.map_err(|_| TransportError::ResponseSendFailed)
    }
}